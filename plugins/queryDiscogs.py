#!/usr/bin/python3
#
# The script will download and save a single
# image from the discogs.com API as an example.
# See README.md for further documentation.
#
import json
import sys
import urllib.parse
# from urllib.parse import urlparse
import pprint

import oauth2 as oauth


def authDiscogs(libPath, verbosity):
    '''
        Authenticate with Discogs online music DB before we query
    '''
    if verbosity >= 2:
        logging.info("Found the following mp3 files")

    # Your consumer key and consumer secret generated by discogs when an application is created
    # and registered . See http://www.discogs.com/settings/developers . These credentials
    # are assigned by application and remain static for the lifetime of your discogs application.
    # the consumer details below were generated for the 'discogs-oauth-example' application.
    consumer_key = 'rKKgbAibQGfTgxmtDMls'
    consumer_secret = 'uwLznJZkzrDDpCOUqpQceljXTyQMUEKA'

    # The following oauth end-points are defined by discogs.com staff. These static endpoints
    # are called at various stages of oauth handshaking.
    request_token_url = 'https://api.discogs.com/oauth/request_token'
    authorize_url = 'https://www.discogs.com/oauth/authorize'
    access_token_url = 'https://api.discogs.com/oauth/access_token'

    # A user-agent is required with Discogs API requests. Be sure to make your user-agent
    # unique, or you may get a bad response.
    user_agent = 'discogs_api_musiclint/1.0'

    # create oauth Consumer and Client objects using
    consumer = oauth.Consumer(consumer_key, consumer_secret)
    client = oauth.Client(consumer)

    # pass in your consumer key and secret to the token request URL. Discogs returns
    # an ouath_request_token as well as an oauth request_token secret.
    resp, content = client.request(request_token_url, 'POST', headers={'User-Agent': user_agent})

    # we terminate if the discogs api does not return an HTTP 200 OK. Something is
    # wrong.
    if resp['status'] != '200':
        sys.exit('Invalid response {0}.'.format(resp['status']))

    if verbosity > 0:
        print("start response: " + '\n')
        pprint.pprint(resp)
        print("end response: " + '\n')

        print("start content: " + '\n')
        pprint.pprint(content)
        print("end content: " + '\n')

    # request_token = dict(urlparse.parse_qsl(content))
    request_token = dict(urllib.parse.parse_qsl(content))

    if verbosity > 0:
        print("start token: " + '\n')
        pprint.pprint(request_token)
        print("end token: " + '\n')

    ot = request_token[b'oauth_token'].decode("utf-8")
    ots = request_token[b'oauth_token_secret'].decode("utf-8")

    if verbosity > 0:
        print("start converted token: " + '\n')
        pprint.pprint(" oauth_token string: " + ot)
        pprint.pprint(" oauth_token string: " + ots)
        print("end token: " + '\n')

        print(' == Request Token == ')
        print('    * oauth_token        = {0}'.format(ot))
        print('    * oauth_token        = {0}'.format(ots))
        
    # will act on behalf of their discogs.com account.
    # If the user accepts, discogs displays a key to the user that is used for
    # verification. The key is required in the 2nd phase of authentication.
    print('Please browse to the following URL {0}?oauth_token={1}'.format(
            authorize_url, ot))

    # Waiting for user input
    accepted = 'n'
    while accepted.lower() == 'n':
        print('\n')
        accepted = input('Have you authorized me at {0}?oauth_token={1} [y/n] :'.format(
            authorize_url, ot))

    # request the verification token from the user.
    oauth_verifier = input('Verification code :')

    # Generate objects that pass the verification key with the oauth token and oauth
    # secret to the discogs access_token_url
    token = oauth.Token(ot, ots)
    token.set_verifier(oauth_verifier)
    client = oauth.Client(consumer, token)

    resp, content = client.request(access_token_url, 'POST', headers={'User-Agent': user_agent})
    UjugggWWDj
    # other local store. All further requests to the discogs.com API that require authentication
    # and must be made with these access_tokens.
    # access_token = dict(urlparse.parse_qsl(content))
    access_token = dict(urllib.parse.parse_qsl(content))

    print("start access token: " + '\n')
    pprint.pprint(access_token)
    print("end access token: " + '\n')

    at = access_token[b'oauth_token'].decode("utf-8")
    ats = access_token[b'oauth_token_secret'].decode("utf-8")

    print("start converted access token: " + '\n')
    pprint.pprint(" oauth_token string: " + at)
    pprint.pprint(" oauth_token string: " + ats)
    print("end converted access token: " + '\n')

    print(' == Access Token ==')
    print('    * oauth_token        = {0}'.format(at))
    print('    * oauth_token_secret = {0}'.format(ats))
    print(' Authentication complete. Future requests must be signed with the above tokens.')
    print('\n')

def queryDiscogs(libPath, verbosity):
    '''
        Query Discogs online music DB 
    '''

    if (at is none):
        authDiscogs()

    # We're now able to fetch an image using the application consumer key and secret,
    # along with the verified oauth token and oauth token for this user.
    token = oauth.Token(key=at,
            secret=ats)
    client = oauth.Client(consumer, token)

    # With an active auth token, we're able to reuse the client object and request 
    # additional discogs authenticated endpoints, such as database search.
    resp, content = client.request('https://api.discogs.com/database/search?release_title=House+For+All&artist=Blunted+Dummies',
            headers={'User-Agent': user_agent})

    if resp['status'] != '200':
        sys.exit('Invalid API response {0}.'.format(resp['status']))

    releases = json.loads(content)
    print('\n== Search results for release_title=House For All, Artist=Blunted Dummies ==')
    for release in releases['results']:
        print('\n\t== discogs-id {id} =='.format(id=release['id']))
        print(u'\tTitle\t: {title}'.format(title=release.get('title', 'Unknown')))
        print(u'\tYear\t: {year}'.format(year=release.get('year', 'Unknown')))
        print(u'\tLabels\t: {label}'.format(label=', '.join(release.get('label',
                    ['Unknown']))))
        print(u'\tCat No\t: {catno}'.format(catno=release.get('catno', 'Unknown')))
        print(u'\tFormats\t: {fmt}'.format(fmt=', '.join(release.get('format',
                    ['Unknown']))))

    # In order to download release images, fetch the release data for id=40522
    # 40522 = http://www.discogs.com/Blunted-Dummies-House-For-All/release/40522
    resp, content = client.request('https://api.discogs.com/releases/40522',
            headers={'User-Agent': user_agent})

    if resp['status'] != '200':
        sys.exit('Unable to fetch release 40522')

    # load the JSON response content into a dictionary.
    release = json.loads(content)
    # extract the first image uri.
    image = release['images'][0]['uri']

    # The authenticated URL is genearted for you. There is no longer a need to
    # wrap the image download request in an OAuth signature.
    # build, send the HTTP GET request for the desired image.
    # DOCS: http://www.discogs.com/forum/thread/410594
    try:
        urllib.urlretrieve(image, image.split('/')[-1])
    except:
        sys.exit('Unable to download image {0}'.format(image))

    print(' == API image request ==')
    print('    * response status      = {0}'.format(resp['status']))
    print('    * saving image to disk = {0}'.format(image.split('/')[-1]))
